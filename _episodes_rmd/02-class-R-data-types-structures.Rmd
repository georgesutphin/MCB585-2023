---
title: "Basic Data Types and Data Structures in R"
classdate: "8/28/2020 -- In Class"
teaching: 90
exercises: 30
questions:
- "What are the most common data types in R?"
- "What are the basic data structures in R?"
- "How do I access data within the basic data structures?"
objectives:
- "Understand the most commonly encountered data types in R and how these data types are used in data structures."
- "Create and manipulate vectors and matrices of different types."
- "Check the data type of a variable, vector, or matrix."
- "Understand the structure and properties of basic data structures (vectors and matrices)."
keypoints:
- "The most commonly encountered data types in R are character, numeric, and logical."
- "R's basic data structures are vectors and matrices."
- "Objects may have attributes, such as name, dimension, and class."
- "Use `object[x]` and `object[x, y]` to select a single element from a 2- and 3-dimensional data structure, respectively."
- "Use `from:to` to specify a sequence that includes the indices from `from` to `to`."
source: Rmd
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-class-R-data-types-structures-")
```

***
## In Class

### Basic Data Types in R

R uses a variety of data types, which define the properties of the value stored in a variable. The three data types that you will use most commonly are **character** (text strings), **logical** (TRUE/FALSE values), and **numeric** (decimal or "double" numeric values) objects. For the most part, the data type of a variable is detected by the format of the value assigned:

```{r}
char1 <- "hello!" # "character" is your basic text string data type
num1 <- 20.5 # "numeric" is your most general data type for real, decimal numbers
logic1 <- TRUE # "logical" data type is a simply binary: TRUE or FALSE
logic2 <- F # T or F also work
```

&nbsp;

Use the `class()` function to determine the of a variable:

```{r}
class(char1)
class(num1)
class(logic1)
```

&nbsp;
#### Character Variables

The **character** data type is used to store basic textual information. A character vector is defined by text in quotes (`""`). You can include most forms of text:

```{r}
greeting <- "How are you today?"
response <- "Just fine. How are you?"
equation <- "1 + 3 - 2 = 2"
```

&nbsp;

The major exception is the backslash (`\`), which R uses as an escape character. In computing, an escape character is a *metacharacter* that is not interpreted literally, but instead causes the computer to interpret *the character following the escape character* in a different way.

```{r}
escape <- "This string \does not compute."
```

&nbsp;

Note that the error message is complaining about the `\d`, not just the `\`. Many characters invoke specific behavior when preceded by the `\` which can be useful depending on your goals. For example, `\n` is interpreted as a *line break*:

```{r}
two.lines <- "Line 1\nLine 2"
writeLines(two.lines)
```

&nbsp;

This can be useful when you are trying to add text to a chart but want the text to appear on separate lines. Some functions just display the string verbatim, instead of trying to interpret the escape characters:

```{r}
print(two.lines)
```
&nbsp;

As you might expect, you can't perform numeric operations on characters:

```{r}
2 * two.lines
```
&nbsp;

You can also successfully print a backslash (`\`) by typing a double backslash (`\\`), which is effectively using the first `\` to "escape" the second `\`:

```{r}
writeLines("Single\\backslash.")
```

&nbsp;

There are many functions for manipulating character data types. Two examples are `paste()`, which combines text strings into a single variable separated by spaces (`paste0()` does the same without the spaces):

```{r}
paste("Hello","world!")
paste0("Hello-","world!")
```

&nbsp;

`sub()` allows you to replace a defined portion of a text string:

```{r}
cat.person <- "I love cats!"
cat.person
dog.person <- sub("cats", "dogs", cat.person)
dog.person
```

&nbsp;
#### Numeric Variables

The **numeric** data type is your most common tool for storing quantitative real numbers:

```{r}
dozen <- 12
dozen
e <- exp(1) # exp is a function that defines the constant e to a given power
e
negatives <- -3.5
negatives
```

&nbsp;

We have already looked at two of many, many functions that manipulate numeric variables:

```{r}
sum(dozen, e, negatives)
sqrt(e)
```

&nbsp;

Some character functions automatically treat numbers (e.g. `12`) as the character equivalent (`"12"`):

```{r}
sub("2","4",dozen)
```

&nbsp;

While others do not:

```{r}
writeLines(dozen)
```

&nbsp;

Just try them to find out!

&nbsp;
### Logical Variables

The **logical** data type is used to store basic TRUE vs. FALSE data:

```{r}
this.is.true <- TRUE
this.is.true
this.is.false <- F
this.is.false
```

&nbsp;

These are useful for asking R questions about your data. For example, we can compare relative values:

```{r}
x <- 4
y <- 5
x < y
```

&nbsp;

This is useful for making decisions, with an `if` statement for example:

```{r}
test1 <- T
test2 <- F
if(test1) "Test 1 is TRUE!"
if(test2) "Test 2 is TRUE!"
```

&nbsp;
The code following the if statement will only execute if the variable or statement entered in the `()` is `TRUE`. We will talk more about how to use `if` statements later in the course.

***
### Data Structures

Elements of these data types may be combined to form data structures--collections of individual datum. There are many data structure in R, for example: 
* factors
* atomic vector (aka vector)
* list
* matrix
* data frame

Here we will discuss the two most basic data structures: **vectors** and **matrices**. In later lessons we will discuss two advanced data structure, **data frames** (the most common data storage structure in R) and **lists**. **Factors** are a type of data structure, but function more like an advanced data type. You will explor **factors** in detail *On Your Own*.  

&nbsp;
#### Vectors

A vector is the most common and basic data structure in R. Vectors are also the major workhorse data structure of R. Technically, vectors can be one of two types:

* atomic vectors
* lists

However, the term "vector" most commonly refers to the atomic types and not to lists. Here we will examine atomic vectors (hereafter just called "vectors"). Lists have a critical place R as well, and will be the topic of a future lesson.

&nbsp;
#### The Different Vector Modes

A vector is a collection of elements that are most commonly of mode `character`, `logical`, `integer` or `numeric`.

You can create an empty vector with the `vector()` function. By default, the mode is `logical`, but you can be more explicit using additional arguments, as shown in the examples below. A simpler solution is to just directly construct vectors of the desired mode using on of several available functions, such as `character()`, `numeric()`, etc.

```{r}
vector() # an empty 'logical' (the default) vector
vector("character", length = 5) # a vector of mode 'character' with 5 elements
character(5) # the same thing, but using the direct constructor function
numeric(5)   # a numeric vector with 5 elements
logical(5)   # a logical vector with 5 elements
```

&nbsp;

You can also create vectors by directly specifying their content. R will then guess the appropriate mode of storage for the vector based on your input data. To do this, you use the function `c()` (which stands for "combine"):

```{r}
# numeric vector
x <- c(1, 2, 3)
class(x)
```

&nbsp;

The `c()` function is the most common way to define a vector of objects for manipulation. Directly specifying `TRUE` and `FALSE` will create a vector of mode `logical`:

```{r}
y <- c(TRUE, TRUE, FALSE, FALSE)
class(y)
```

&nbsp;

While quoted text will create a vector of mode `character`:

```{r}
z <- c("Sarah", "Tracy", "Jon")
class(z)

# adding quotes to numbers forces a character vector
x.char <- c("1", "2", "3")
class(x.char)
```

&nbsp;
#### Adding Elements

The function `c()` can also be used to add elements to a vector:

```{r}
z <- c(z, "Annette")
z
z <- c("Greg", z)
z
```

&nbsp;

Note that order matters and defines the order in the output vector. `c()` treats any argument that is a vector as just another set of elements in the list.

&nbsp;
#### Vectors from a Sequence of Numbers

Use the `seq()` function or the `:` operator to create a vector as a sequence of numbers.

```{r}
seq(10)
1:10
seq(from = 1, to = 10, by = 0.1)
```

&nbsp;

You can assign these sequences directly to a variable:

```{r}
series1 <- 5:15
series1
series2 <- seq(from = 3, to = 8, by = 0.2)
series2
```

&nbsp;
#### What happens when you mix types inside a vector?

R will create a resulting vector with a mode that can most easily accommodate all the elements it contains (similar to using the `as.` functions). This conversion between modes of storage is called "coercion". When R converts the mode of storage based on its content, it is referred to as "implicit coercion". 

> ## Mixing data types in vectors
> 
> What the do you think the following will do (without running them first)?
> 
> ```{r, eval=FALSE}
> z1 <- c(1.7, "a")
> z2 <- c(TRUE, 2)
> z3 <- c("a", TRUE)
> ```
> > ## Solution
> > 
> > ```{r}
> > z1 <- c(1.7, "a") 
> > class(z1)
> > ```
> > `z1` is forced to be a character vector. `"1.7"` can be a character, while 
> > `"a"` cannot be a number.
> > 
> > ```{r}
> > z2 <- c(TRUE, 2) 
> > class(z2)
> > ```
> > `z2` is forced to be a numeric vector. `TRUE` can be interpreted as a number 
> > (`TRUE` = `1`, `FALSE` = `0`), while `2` cannot be interpreted as a logical 
> > value (or can it?)
> > 
> > ```{r}
> > z3 <- c("a", TRUE)
> > class(z3)
> > ```
> > `z3` is forced to be a character vector. `"TRUE"` can be a character, while 
> > `"a"` cannot be interpreted as a logical value
> > 
> {: .solution}
{: .challenge}

&nbsp;

> ## Finding commonalities
>
> What two properties are common to all of the vectors above?
> > ## Solution
> > Properties of vectors:
> > * All vectors are one-dimensional
> > * Each vector element is of the same type.
> {: .solution}
{: .challenge}

&nbsp;
#### Indexing vectors

In R, `[]` are used to index vectors and other objects. For vectors, the number entered in the `[n]` will return the nth element of the vector.

```{r}
x <- c("a","b","c","d","e","f")
x
x[5]
```

&nbsp;

You can also use pre-defined variables or even other vectors to index different parts of the vector:

```{r}
n <- 6
range <- 2:4

x[n] # returns the 6th element, as defined by n = 6
x[range] # returns the range of values specified by "range", in this case elements 2 to 4.
```

> ## Subsetting data
>
> Let's look at a different subsetting option using a character vectors:
>
> ```{r}
> animal <- c("m", "o", "n", "k", "e", "y")
> 
> # first three characters
> animal[1:3]
> # last three characters
> animal[4:6]
> ```
>
> &nbsp;
>
> Consider the following questions:
>
> 1.  If the first four characters are selected using the subset `animal[1:4]`, 
> how can we obtain the first four characters in reverse order?
>
> 2. What output results from `animal[-1]`?
> 
> 3. What ouptut results from `animal[-4]`?
>
> 4. Given 1-3, what do you expect `animal[-1:-4]` to produce?
>
> 5. Use a subset of the `animal` vector to create a new character vector that spells the word "main", i.e. `c("m", "a", "i", "n")`.
>
> > ## Solutions
> > 
> > 1. `animal[4:1]`
> > 
> > 2. `"o" "n" "k" "e" "y"`
> > 
> > 3. `"m" "o" "n" "e" "y"`, which means that a single `-` removes the element 
> > at the given index position.
> > 
> > 4. `animal[-1:-4]` remove the subset at indexes 1 to 4, returning `"e" "y"`,
> > which is equivalent to `animal[5:6]`.
> > 
> > ```{r}
> > animal[-1:-4]
> > animal[5:6]
> > ```
> > 
> > 5. `animal[c(5,2,3)]` combines indexing with the `c`ombine function to 
> > spell the word "eon" in a new vector:
> > 
> > ```{r}
> > animal[c(5,2,3)]
> > ```
> {: .solution}
{: .challenge}

&nbsp;

We will talk about more advanced indexing strategies later in the course.

&nbsp;
#### Vectorized operations

R has a special way of dealing with vectors when dealing with operations. We know what to expect from `1 + 1`, but what happens if you try to add two vectors?

```{r}
x <- c(1,2,3)
y <- c(4,5,6)

z <- x + y
z
```

&nbsp;

R creates a new vector in which each element the sum of the elements with the same index from x and y. In essence, R is performing 3 separate "addition" operations and combining the results into a new vector. We can mimick this behavior manually:

```{r}
z1 <- x[1] + y[1]
z2 <- x[2] + y[2]
z3 <- x[3] + y[3]

z <- c(z1, z2, z3)
z
```

&nbsp;

This process is called "vectorization". It works for most mathematical operations:
```{r}
x - y
x * y
x / y
x ^ y
```

&nbsp;

Many functions also behave in a vectorized manner. Take the `paste()` function, for example, which combines two or more character variables into a single variable:

```{r}
# Here is the output with two strings
paste("I like", "dogs.")

# Now let's try pasting two character vectors together:
attitude <- c("I like","I dislike","I am indifferent to")
animal <-  c("dogs.","fish.","cats.")

paste(attitude,animal)
```

&nbsp;

Depending on how they are written and the way their input/output works, some functions may not act on the vector, but on the list of values in the vector. The best way to find out is to just give it a try. 


***
### Objects Attributes

R objects can have **attributes**. Attributes are metadata and part of the object. Each attribute describes a different aspect of the object. These include:

* **names** -- some objects (e.g. lists) have named elements
* **dim** -- the number of rows and columns in a matrix
* **class** -- the data type of an object
* **attributes** -- a list containing other forms of metadata of more complex objects

While technically not assigned *attributes*, you can also glean other attribute-like metadata information from objects such as length (works on vectors and lists) or number of characters (for character strings).

```{r}
length(1:10)
nchar("MCB 585")
```

&nbsp;

We will periodically use object attributes to manipulate objects throughout the course.

***
### Matrices

In R matrices are an extension of vectors. They are not a separate type of object but simply an atomic vector with dimensions; the number of rows and columns. As with atomic vectors, the elements of a matrix must be of the same data type. Like vectors, we can use the generic `matrix()` function to build a matrix. Unlike vectors, there is no direct equivalent for each data type (e.g. `character()`):

```{r}
# first create a vector, then coerce that vector into a matrix:
v <- 1:4
m <- matrix(data = v, nrow = 2, ncol = 2)

# note the difference in structure
v
m
```

&nbsp;

We can no examine some of the attributes of our new matrix `m`:

```{r}
dim(m)
attributes(m)
```

&nbsp; 

Note that under the surface, R still treats `m` as a vector, so the `length()` of `v` and `m` are the same (i.e. both contain 4 elements):

```{r}
length(v)
length(m)
```

&nbsp;

Matrices are a higher-oder object (a vector with additional properties). Thus the `class()` function no longer tells you the data type for each element, but rather the data structure type of the entire object:

```{r}
class(m)
```

&nbsp;

You can check the data type of the elements of the matrix using `typeof()`:

```{r}
typeof(m)
```

&nbsp;

While `class()` shows that m is a matrix, `typeof()` shows that fundamentally the
matrix is an integer vector.

Note that one difference between vectors and matrices is that an otherwise identical vector will return the data type of each element when you use `class()`, while the matrix is a new type of object with `class()` "matrix".

> ## Data types of matrix elements
> 
> Consider the following matrix:
> 
> ```{r matrix-typeof}
> FOURS <- matrix(
>   c(4, 4, 4, 4),
>   nrow = 2,
>   ncol = 2)
> ```
>
> Given that `typeof(FOURS[1])` returns `"double"`, what would you expect
> `typeof(FOURS)` to return? How do you know this is the case even without
> running this code?
>
> > ## Solution
> > We know that `typeof(FOURS)` will also return `"double"` since matrices 
> > are just vectors, and vectors must be made of elements of the same data
> > type. Note that you could do something like `as.character(FOURS)` if you
> > needed the elements of `FOURS` to be *characters*.
> {: .solution}
{: .challenge}

&nbsp;

By default, matrices in R are filled column-wise:

```{r}
m1 <- matrix(1:6, nrow = 2, ncol = 3)
m1
```

... unless you tell it to fill by row explicitly using the `byrow` argument:

```{r}
m2 <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)
m2
```

&nbsp;

Other ways to construct a matrix

```{r}
m <- 1:10

# so far m is just a vector!
m
class(m)

# defining the "dimensions" attribute automatically converts m to a matrix
dim(m) <- c(2, 5)
m
class(m)
```

&nbsp;

This takes a vector and transforms it into a matrix with 2 rows and 5 columns.

Another way is to bind columns or rows using `rbind()` and `cbind()` ("row bind"
and "column bind", respectively).

```{r}
x <- 1:3
y <- 10:12
cbind(x, y)
rbind(x, y)
```

&nbsp;
#### Indexing matrices

Like vectors, `[]` are used to index matrices. Since matrices are, by definition, two-dimensional, use `[m,n]` to index the *m*th row and *n*th column of a matrix. The row is always specified before the `,` and the column after.

```{r}
m <- matrix(1:10, nrow = 2, ncol = 5)
m
m[2, 3]
```

&nbsp;

If you are only interested in indexing a specific row, but do not want to change the columns, you can just leave the column index blank (but don't forget the `,`!):

```{r}
m[2,]
```


> ## Subsetting data
>
> Let's look at a different ways to manipulate matrices. First, let's define
> a simple matrix to play with:
>
> ```{r}
> m <- matrix(1:12, nrow=3)
> m
> ```
>
> &nbsp;
>
> Keeping in mind what you know about the behavior of vectors, consider the  
> following questions:
>
> 1. How can you use indexing to extract the middle of the matrix (e.g. `5` 
> and `8`)?
>
> 2. What output do you expect from `m[-2,]`?
>
> 3. What output do you expect from `m[,2:3]`?
> 
> 4. What result do expect when you try including `m` in simple 
> multiplication: `2*m`?
>
> 5. Can you predict what will happen if you try `m[,c(1,3)]`?
>
> 6. There is a useful function `t()`. Try `t(m)`. Based on the output,
> what does `t()` do? What do you think the `t` stands for?
>
> 7. What happens if we only ask for a single index (`m[4]`)? 
> 
> > ## Solutions
> > 
> > 1. The numbers `5` and `8` appear in the second row, and the second and third > > columns, respectively. To extract this matrix subset, we use the index:
> >
> > ```{r}
> > m[2,2:3]
> > ```
> > 
> > &nbsp;
> >
> > {:start="2"}
> > 2. Like in vectors, the `-` tells R to exclude the index that follows. In 
> > this case, exclude row 2. The column index is blank, so all columns are 
> > returned. Thus we end up with a smaller matrix with only rows 1 and 3, and 
> > all elements in row 2 removed:
> >
> > ```{r, echo=FALSE}
> > m[-2,]
> > ```
> > 
> > &nbsp;
> >
> > {:start="3"}
> > 3. As with vectors, including a set of sequential values in either index
> > will return all of the indexes in that range. In this case rows are blank
> > (so include all rows), and columns 2-3 are requested, so we will get the 
> > following 2x2 matrix:
> >
> > ```{r, echo=FALSE}
> > m[,2:3]
> > ```
> >  
> > &nbsp;
> >
> > {:start="4"}
> > 4. Because matrices are essentially vectors with attributes, all standard
> > operations are "vectorized". We thus expect a new matrix with the same 
> > dimensions as m, but with each element equal to twice the corresponding 
> > element in m:
> > 
> > ```{r, echo = FALSE}
> > 2*m
> > ```
> > 
> > &nbsp;
> >
> > {:start="5"}
> > 5. While we haven't covered it explicity, entering `2:3` into an index
> > (like in question 3) is equivalent to entering an list of values (e.g. 
> > `c(2,3)`). Any list of this sort can be used to index a specific (and 
> > not necessarily sequential) set of rows or columns. Thus we expect 
> > the list `c(1,3)` entered into the column index to return columns 1 and 3:
> > 
> > ```{r, echo=FALSE}
> > m[,c(1,3)]
> > ```
> > 
> > &nbsp;
> >
> > {:start="6"}
> > 6. Let's see what happens if we use the `t()` function on `m`:
> > 
> > ```{r}
> > t(m)
> > ```
> > 
> > &nbsp;
> > 
> > The `t` stands for "transpose", and as we can see from the result, `t(m)`
> > simply "flips" the matrix so that rows are now columns and columns are now
> > rows.
> > 
> > &nbsp;
> > 
> > {:start="7"}
> > 7. Since a matrix is just a fancy vector, requesting R to return the 4th
> > index (`m[4]`) will simply return the 4th value in the underlying vector:
> > 
> > ```{r, echo=FALSE}
> > m[4]
> > ``` 
> {: .solution}
{: .challenge}

&nbsp;

What if we ask for an index outside the range of a matrix?

```{r}
m[3,15]
```

&nbsp;

This error universally occurs whenever you request an invalid index to an object in R (vector, matrix, list, data frame, etc.)

***

{% include links.md %}
